function initAnnotation(annotateType) {
  const canvasData = new CanvasData(annotateType)
  const buttonData = new ButtonData(annotateType)

  if (canvasData.exists) {
    const drawingManager = new DrawingManager(canvasData);
    canvasData.$canvas.on("touchstart touchmove", (event) => event.preventDefault()); // ÌÑ∞Ïπò Î∞©ÏßÄ

    // ÎßàÏö∞Ïä§ ÎèôÏûë Ï≤òÎ¶¨
    drawingManager.tool.onMouseDown = (event) => drawingManager.handleMouseDown(event);
    drawingManager.tool.onMouseDrag = (event) => drawingManager.handleMouseDrag(event);
    drawingManager.tool.onMouseUp = (event) => drawingManager.handleMouseUp(event);

    // Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
    buttonData.$drawingBtn.on("click", () => buttonData.handleDrawingBtn(drawingManager, "drawing"));
    buttonData.$lineBtn.on("click", () => buttonData.handleDrawingBtn(drawingManager, "line"));
    buttonData.$highlighterBtn.on(
        "click", () => buttonData.handleDrawingBtn(drawingManager, "highlighter"));
    buttonData.$eraserBtn.on("click", () => buttonData.handleDrawingBtn(drawingManager, "eraser"));
    buttonData.$colorBtn.on("click", (event) => buttonData.handleColorBtn(event, drawingManager));

    buttonData.$undoBtn.on("click", () => drawingManager.undo());
    buttonData.$redoBtn.on("click", () => drawingManager.redo());
    buttonData.$loadBtn.on("click", () => drawingManager.loadDrawing());
    buttonData.$saveBtn.on("click", () => drawingManager.saveDrawing());
    buttonData.$clearBtn.on("click", () => drawingManager.clearAllDrawings());
  }
}


function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}


function getCSRFToken() {
  return $("[name=csrfmiddlewaretoken]").attr("value");
}


function totalInitAnnotation() {
  initAnnotation("normal");
  initAnnotation("wide");
}


$(window).on("load", totalInitAnnotation);
$("body").on("initAnnotation", totalInitAnnotation);


class CanvasData {
  constructor(annotateType) {
    this.annotateType = annotateType;

    // jQuery Í∞ùÏ≤¥ Ï†ïÏùò
    this.$canvas = $(`#${annotateType}Canvas`);
    this.$image = $(`#${annotateType}Image`);

    // Ï∫îÎ≤ÑÏä§, Ïù¥ÎØ∏ÏßÄ, ÌïÑÍ∏∞ Ï≤òÎ¶¨ Ï£ºÏÜå Ï†ïÏùò
    this.canvas = this.$canvas[0]
    this.image = this.$image[0]
    this.annotateUrl = `${this.$canvas.attr("data-annotate-url")}?annotate_type=${annotateType}`

    this.exists = this.$canvas.length && this.$image.length;
    if (this.exists) {
      this.$image.on("load", this.resizeCanvasToImage);
      this.resizeCanvasToImage();
    }
  }

  resizeCanvasToImage() {
    this.canvas.width = this.image.clientWidth;
    this.canvas.height = this.image.clientHeight;
  }
}


class ButtonData {
  constructor(annotateType) {
    // jQuery Í∞ùÏ≤¥ Ï†ïÏùò
    this.annotateType = annotateType
    this.$drawingBtn = $(`#${annotateType}DrawingBtn`);
    this.$lineBtn = $(`#${annotateType}LineBtn`);
    this.$highlighterBtn = $(`#${annotateType}HighlighterBtn`);
    this.$eraserBtn = $(`#${annotateType}EraserBtn`);
    this.$colorBtn = $(`.${annotateType}-color-btn`);
    this.$clearBtn = $(`#${annotateType}ClearBtn`);
    this.$undoBtn = $(`#${annotateType}UndoBtn`);
    this.$redoBtn = $(`#${annotateType}RedoBtn`);
    this.$saveBtn = $(`#${annotateType}SaveBtn`);
    this.$loadBtn = $(`#${annotateType}LoadBtn`);
  }

  getButtonAndStatusJquery(property) {
    let statusId = this.annotateType + capitalizeFirstLetter(property) + 'Status';
    let button = this[`$${property}Btn`];
    let status = $(`#${statusId}`);
    return [button, status]
  }

  toggleDrawingStatus(drawingManager, property) {
    let [button, status] = this.getButtonAndStatusJquery(property);
    drawingManager[`${property}Enabled`] = button.prop("checked");
    status.toggleClass(`${property}-enabled`);
  }

  toggleDrawingBtn(property, isActive) {
    let [button, status] = this.getButtonAndStatusJquery(property);
    if (isActive) {
      button.prop("checked", true).trigger("change");
      status.addClass("enabled");
    } else {
      button.prop("checked", false).trigger("change");
      status.removeClass("enabled");
    }
  }

  activateDrawingPropertyBtn() {
    this.toggleDrawingBtn("drawing", true);
    this.toggleDrawingBtn("eraser", false);
  }

  deactivateDrawingBtn() {
    this.toggleDrawingBtn("drawing", false);
    this.toggleDrawingBtn("line", false);
    this.toggleDrawingBtn("highlighter", false);
    this.toggleDrawingBtn("eraser", false);
  }

  handleDrawingBtn(drawingManager, property) {
    this.toggleDrawingStatus(drawingManager, property);

    if (property === 'eraser') {
      if (drawingManager.eraserEnabled) {
        drawingManager.drawingEnabled = true;
        this.toggleDrawingBtn("drawing", true);
      }
    } else {
      if (drawingManager[`${property}Enabled`]) {
        drawingManager.activateDrawing();
        this.activateDrawingPropertyBtn();
      }

      if (!drawingManager.drawingEnabled) {
        drawingManager.deactivateDrawing();
        this.deactivateDrawingBtn();
      }
    }
    drawingManager.adjustHighlighterSettings();
  }

  handleColorBtn(event, drawingManager) {
    this.$colorBtn.removeClass("active");
    event.currentTarget.classList.add("active");

    const selectedColor = event.currentTarget.dataset["color"];
    let colorcode = DrawingManager.colorMap[selectedColor];

    if (colorcode) {
      drawingManager.currentColor = `rgba(${colorcode}, ${drawingManager.opacity})`; // RGBA Ï†ÅÏö©
      drawingManager.activateDrawing();
      this.activateDrawingPropertyBtn();
    }
  }
}


class DrawingManager {
  static defaultOpacity = Object.freeze(0.4);
  static defaultStrokeWidth = Object.freeze(2);
  static defaultBlendMode = Object.freeze("normal");

  static highlighterOpacity = Object.freeze(0.3);
  static highlighterBlendMode = Object.freeze("multiply");

  static colorMap = {
    black: "0, 0, 0",
    red: "255, 0, 0",
    blue: "0, 0, 255",
    green: "0, 128, 0",
    yellow: "255, 234, 0",
    orange: "255, 165, 0"
  }

  static angleStep = Math.PI / 100;

  constructor(canvasData) {
    this.canvasData = canvasData;
    this.canvasWidth = canvasData.canvas.width;
    this.highlighterStrokeWidth = this.canvasWidth / 50;

    this.drawingEnabled = false;
    this.lineEnabled = false;
    this.highlighterEnabled = false;
    this.eraserEnabled = false;

    this.opacity = DrawingManager.defaultOpacity;
    this.currentColor = `rgba(0, 0, 0, ${this.opacity})`;
    this.strokeWidth = DrawingManager.defaultStrokeWidth;
    this.blendMode = DrawingManager.defaultBlendMode;

    this.startPoint = null;
    this.previewLine = null;

    this.path = null;
    this.selectedPath = null;
    this.eraserPath = null;

    this.originalAttributes = {};
    this.redoStack = []; // ÎêòÎèåÎ¶¨Í∏∞ Ï∑®ÏÜåÎ•º ÏúÑÌïú Ï†ÄÏû• Í≥µÍ∞Ñ

    this.paperScope = new paper.PaperScope(); // Í∞úÎ≥ÑÏ†ÅÏù∏ PaperScope ÏÉùÏÑ±
    this.paperScope.setup(canvasData.canvas); // Ìï¥Îãπ Ï∫îÎ≤ÑÏä§Ïóê Paper.js ÏÑ§Ï†ï
    this.tool = new this.paperScope.Tool(); // Í∞úÎ≥ÑÏ†ÅÏù∏ Tool ÏÉùÏÑ±
  }

  adjustHighlighterSettings() {
    this.opacity = this.highlighterEnabled ? DrawingManager.highlighterOpacity : DrawingManager.defaultOpacity;
    this.strokeWidth = this.highlighterEnabled ? this.highlighterStrokeWidth : DrawingManager.defaultStrokeWidth;
    this.blendMode = this.highlighterEnabled ? DrawingManager.highlighterBlendMode : DrawingManager.defaultBlendMode;
  }

  // üìå ÌïÑÍ∏∞ Î™®Îìú ÏÑ§Ï†ï
  deactivateDrawing() {
    this.drawingEnabled = false;
    this.lineEnabled = false;
    this.highlighterEnabled = false;
    this.eraserEnabled = false;
  }

  activateDrawing() {
    this.drawingEnabled = true;
    this.eraserEnabled = false;
  }

  getHitResults(event) {
    const point = this.getEventPoint(event)
    return this.paperScope.project.hitTestAll(
        point, {segments: true, stroke: true, tolerance: 5});
  }

  getEventPoint(e) {
    const offset = this.canvasData.$canvas.offset();
    const touch = e.event && e.event.touches ? e.event.touches[0] : e.event || e;
    const x = (touch.pageX || touch.clientX) - offset.left;
    const y = (touch.pageY || touch.clientY) - offset.top;
    return new paper.Point(x, y);
  }

  handleMouseDown(event) {
    const hitResults = this.getHitResults(event);
    const strokeType = this.highlighterEnabled ? 'highlighter' : 'normal'
    console.log(hitResults);

    function isStrokeForSelect(hitResults) {
      return hitResults.length && hitResults[0].type !== 'pixel' && hitResults[0].item.strokeType !== 'eraser'
    }

    if (isStrokeForSelect(hitResults)) return this.selectPath(hitResults[0].item);
    this.deselectPath();

    if (this.eraserEnabled) return this.mouseDownEraserFunction(hitResults, event);
    if (this.lineEnabled) return this.createPreviewLine(event, strokeType);
    if (this.drawingEnabled) return this.createPath(event, strokeType);
  }

  selectPath(path) {
    if (!path) return;

    // Í∏∞Ï°¥ ÏÑ†ÌÉùÎêú ÌïÑÍ∏∞ Ìï¥Ï†ú
    this.deselectPath();

    // ÏÉà ÌïÑÍ∏∞ ÏÑ†ÌÉù Î∞è ÏÜçÏÑ± Ï†ÄÏû•
    this.selectedPath = path;
    this.originalAttributes = {
      strokeWidth: this.selectedPath.strokeWidth,
      strokeColor: this.selectedPath.strokeColor,
      opacity: this.selectedPath.opacity,
    };

    // Í∞ïÏ°∞ Ìö®Í≥º Ï†ÅÏö©
    if (path.strokeType === 'normal') {
      this.selectedPath.strokeWidth = 4;
      this.selectedPath.strokeColor = 'red';
    } else if (path.strokeType === 'highlighter') {
      this.selectedPath.opacity = 0.8;
    }
  }

  deselectPath() {
    if (this.selectedPath) {
      this.selectedPath.strokeWidth = this.originalAttributes.strokeWidth;
      this.selectedPath.strokeColor = this.originalAttributes.strokeColor;
      this.selectedPath.opacity = this.originalAttributes.opacity;
      this.selectedPath = null;
      this.originalAttributes = {};
    }
  }

  isStrokeForEraser(result) {
    return result.type !== 'pixel' && result.item.strokeType !== 'eraser'
  }

  mouseDownEraserFunction(hitResults, event) {
    if (hitResults.length) {
      hitResults.forEach(result => {
        if (this.isStrokeForEraser(result)) {
          result.item.remove();
          this.paperScope.view.update();
        } else if (result.type === 'pixel') {
          this.createEraserPath(event);
        }
      });
    } else {
      this.createEraserPath(event);
    }
  }

  createEraserPath(event) {
    this.eraserPath = new paper.Path({
      strokeColor: 'black',
      strokeWidth: 20,
      strokeCap: 'round',
      blendMode: 'destination-out',
      strokeType: 'eraser',
    });
    this.eraserPath.add(event.point);
  }

  createPreviewLine(event, strokeType) {
    this.startPoint = event.point;
    this.previewLine = new paper.Path({
      strokeColor: this.currentColor,
      strokeWidth: this.strokeWidth,
      strokeType: strokeType,
    });
    this.previewLine.add(this.startPoint);
    this.previewLine.add(this.startPoint); // Ï¥àÍ∏∞ÏóêÎäî Í∞ôÏùÄ Ï†êÏúºÎ°ú ÏÑ§Ï†ï
  }

  createPath(event, strokeType) {
    this.path = new this.paperScope.Path({
      strokeColor: this.currentColor,
      strokeWidth: this.strokeWidth,
      blendMode: this.blendMode,
      strokeType: strokeType,
    });
    this.path.add(event.point);
  }

  handleMouseDrag(event) {
    if (this.selectedPath) return this.moveSelectedPath(event);
    if (this.eraserEnabled) return this.mouseDragEraserFunction(event);
    if (this.drawingEnabled && this.path) return this.path.add(event.point);
    if (this.lineEnabled && this.previewLine) return this.adjustPreviewLine(event);
  }

  moveSelectedPath(event) {
    this.selectedPath.position = this.selectedPath.position.add(event.delta); // ÌïÑÍ∏∞ Ïù¥Îèô
  }

  mouseDragEraserFunction(event) {
    const hitResults = this.getHitResults(event);
    if (hitResults.length) {
      hitResults.forEach(result => {
        if (this.isStrokeForEraser(result)) {
          result.item.remove();
          this.paperScope.view.update();
        } else if (this.eraserPath) {
          this.eraserPath.add(event.point);
        }
      });
    }
  }

  adjustPreviewLine(event) {
    let dx = event.point.x - this.startPoint.x;
    let dy = event.point.y - this.startPoint.y;
    let angle = Math.atan2(dy, dx); // ÌòÑÏû¨ Í∞ÅÎèÑ Í≥ÑÏÇ∞
    let snappedAngle = Math.round(angle / DrawingManager.angleStep) * DrawingManager.angleStep;
    let length = Math.sqrt(dx * dx + dy * dy);
    let newX = this.startPoint.x + length * Math.cos(snappedAngle);
    let newY = this.startPoint.y + length * Math.sin(snappedAngle);

    this.previewLine.lastSegment.point = new this.paperScope.Point(newX, newY);
  }

  handleMouseUp() {
    const strokeType = this.highlighterEnabled ? 'highlighter' : 'normal'

    if (this.eraserEnabled) return this.mouseUpEraserFunction();
    if (this.lineEnabled && this.startPoint) return this.createPathFromPreviewLine(strokeType);
    if (this.drawingEnabled && this.path) return this.simplifyPath();
  }

  mouseUpEraserFunction() {
    this.eraserPath = null;
  }

  createPathFromPreviewLine(strokeType) {
    //ÏµúÏ¢Ö ÏßÅÏÑ† ÏÉùÏÑ±
    const path = new this.paperScope.Path({
      strokeColor: this.currentColor,
      strokeWidth: this.strokeWidth,
      strokeType: strokeType,
    });
    path.add(this.startPoint);
    path.add(this.previewLine.lastSegment.point); // Ï°∞Ï†ïÎêú ÎÅùÏ†ê ÏÇ¨Ïö©

    // ÏûÑÏãú ÏßÅÏÑ† Ï†úÍ±∞
    this.previewLine.remove();
    this.previewLine = null;
    this.startPoint = null; // ÏãúÏûëÏ†ê Ï¥àÍ∏∞Ìôî
  }

  simplifyPath() {
    this.path.simplify();
    this.path = null;
  }

  undo() {
    const items = this.paperScope.project.activeLayer.children;

    if (items.length > 0) {
      const lastItem = items[items.length - 1]; // ÎßàÏßÄÎßâ ÏöîÏÜå Í∞ÄÏ†∏Ïò§Í∏∞
      this.redoStack.push(lastItem); // ÎêòÎèåÎ¶¨Í∏∞ Ï∑®ÏÜåÎ•º ÏúÑÌï¥ Ï†ÄÏû•
      lastItem.remove(); // ÎßàÏßÄÎßâ ÏöîÏÜå Ï†úÍ±∞
      this.paperScope.view.update(); // ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
    } else {
      alert("ÎêòÎèåÎ¶¥ ÌïÑÍ∏∞ ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§!");
    }
  }

  redo() {
    if (this.redoStack.length > 0) {
      const restoredItem = this.redoStack.pop(); // Ï†ÄÏû•Îêú ÏöîÏÜå Í∞ÄÏ†∏Ïò§Í∏∞
      this.paperScope.project.activeLayer.addChild(restoredItem); // Îã§Ïãú Ï∂îÍ∞Ä
      this.paperScope.view.update(); // ÌôîÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏
    } else {
      alert("ÎêòÎèåÎ¶¨Í∏∞ Ï∑®ÏÜåÌï† ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§!");
    }
  }

  loadDrawing() {
    if (!confirm("Ï†ÄÏû•Îêú ÌïÑÍ∏∞ Ïù¥ÎØ∏ÏßÄÎ•º Î∂àÎü¨Ïò§ÏãúÍ≤†ÏäµÎãàÍπå?\nÌòÑÏû¨ ÌïÑÍ∏∞ ÎÇ¥Ïö©ÏùÄ ÏÇ≠Ï†úÎê©ÎãàÎã§.")) {
      return;
    }

    fetch(this.canvasData.annotateUrl)
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            this.paperScope.setup(this.canvasData.canvas); // Ìï¥Îãπ Ï∫îÎ≤ÑÏä§Ïóê Paper.js ÏÑ§Ï†ï
            this.canvasData.resizeCanvasToImage();

            const raster = new this.paperScope.Raster({
              source: data.image_url,
              position: this.paperScope.view.center
            })
            raster.sendToBack();
            raster.onLoad = () => {
              raster.fitBounds(this.paperScope.view.bounds, true); // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Ïóê ÎßûÍ≤å Ï°∞Ï†ï
            }
          } else {
            alert("Ï†ÄÏû•Îêú ÌïÑÍ∏∞ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.");
          }
        })
        .catch(error => alert("‚ùå Î∂àÎü¨Ïò§Í∏∞ Ï§ë Ïò§Î•ò Î∞úÏÉù: " + error));
  }

  saveDrawing() {
    if (!confirm("ÌòÑÏû¨ ÌïÑÍ∏∞ ÎÇ¥Ïö©ÏùÑ Ï†ÄÏû•ÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
      return;
    }

    if (!this.canvasData.$canvas) {
      alert("‚ùå Ï∫îÎ≤ÑÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§!");
      return;
    }

    fetch(this.canvasData.annotateUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCSRFToken() // CSRF ÌÜ†ÌÅ∞ Ï∂îÍ∞Ä
      },
      body: JSON.stringify({
        annotateType: this.canvasData.annotateType,
        image: this.canvasData.canvas.toDataURL("image/png"),
      })
    })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            alert("‚úÖ ÌïÑÍ∏∞ ÎÇ¥Ïö©Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!");
          } else {
            alert("‚ùå Ï†ÄÏû• Ïã§Ìå®: " + data.error);
          }
        })
        .catch(error => alert("‚ùå Ï†ÄÏû• Ï§ë Ïò§Î•ò Î∞úÏÉù: " + error));
  }

  clearAllDrawings() {
    if (!confirm("Ï†ÑÏ≤¥ ÌïÑÍ∏∞ ÎÇ¥Ïö©ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
      return;
    }
    this.paperScope.project.activeLayer.removeChildren();
    this.paperScope.view.update();
  }
}
